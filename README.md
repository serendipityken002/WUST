### 快速启动
1. 运行串口服务器和数据库服务器
```bash
python server.py
python sb_test.py
```

2. 运行后端
```bash
python back.py
```

### 明确项目模块职责划分

1 后端
- 发送所有需要连接的串口给串口服务器，让其创建串口对象
- 接收前端JSON命令，将其解析为modbus帧，存入发送队列
- 将发送队列给串口服务器，串口服务器处理后会返回设备信息的modbus帧
- 接收串口服务器返回的modbus帧，存入接收队列，最后依次解析为JSON格式


2 串口服务器
- 接收后端提供的串口名、波特率等信息，创建串口对象
- 编写串口处理类和串口管理类对串口设备进行实际操作，包括提供串口数据接收、发送、关闭接口
- 根据{串口名: 串口对象}字典，提供串口名和modbus帧即可发送数据

3 数据库
- 只负责存储配置信息和设备实际数据
- 不需要把串口信息存储到数据库中

需要商榷的地方：
1. 不同模块间交互方式：
- 后端和串口服务器都是放在服务器电脑上跑，意味着他们的交互只需要调用函数即可。之前做了TCP协议是为了方便测试工具能内网穿透连接到后端，这里应该就是**上位机软件通过TCP连接到后端吗？** 与此同时，前端连接后端是通过HTTP协议的，他没走我写的TCP协议，也就是**前端直接调用后端的API接口**。上面两个都需要连接后端，但他们通过不同的方式，是否有些多余？
- TCP协议通过socket库实现，HTTP协议通过flask库实现。TCP协议是我写的，HTTP协议是当初江大服务器连接前端写的。
各模块间全部使用TCP协议

1. 寻找可用串口函数的位置
我们是通过串口的名字匹配端口号，例如"Ch B"查找到"COM 5"。这个步骤放在后端还是串口服务器？
选择串口服务器

### 接口文档

1 前端发送的json请求
请求格式：
```python
json_data = {
    'serial': 'COM 50',
    'slave_adress': '1',
    'function_code': '3',
    'start_address': '2',
    'quantity': '4',
}
```

2 后端发送数据给串口服务器

2.1 发送所有需要连接的串口给串口服务器，让其创建串口对象
数据格式如下：
```bash
[
{"name": "COM44", "description": "WCH USB-SERIAL Ch A", "baudrate": 9600, "timeout": 1, "db_id": 1}, 
{"name": "COM45", "description": "WCH USB-SERIAL Ch C", "baudrate": 9600, "timeout": 1, "db_id": 2}, 
{"name": "COM50", "description": "WCH USB-SERIAL Ch D", "baudrate": 9600, "timeout": 1, "db_id": 3}
]
```

2.2 接收前端JSON命令，将其解析为modbus帧，存入发送队列后即可发给后端服务器
数据格式如下：
```python
data = json.dumps({
    'serial': serial,
    'request': request,
    'time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),
})
```

2.3 接收串口服务器返回的modbus帧，按字节存入接收队列
串口服务器返回数据：
```python
data = json.dumps({
    "serial": serial,
    "request": request,
    "response": response,
    "time": time
})
```

### 问题
1 串口服务器如何处理数据？
串口的连接是在串口服务器实现的，也就是后端发给串口服务器的数据一定是要携带串口名的。同样，串口服务器返回时也不能仅返回modbus帧，也要携带串口名。那该如何设计缓冲队列？之前能按字节存储是每个串口都有自己的队列，这样才会不需要携带串口名。

2 解析数据
我发现不同设备的不仅端口号不同，从机号也都不同。解析数据的时候，不需要看是哪个串口，只需要知道从机号就可以解析了吗？

接口写好、完善框架图、串口服务器接上硬件、后端
- 将所有发送指令放在json文件中，通过读取获得
- 串口配置信息（初始化串口）放在数据库，上位机改数据库即可
- 数据库的队列也需要时间
- 最后需要实际跑通代码，结合实际硬件回复数据